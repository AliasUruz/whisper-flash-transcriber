# .github/workflows/codex-automation.yml (Vers√£o 4.1: Modelo H√≠brido - Reativo + Agendado)

name: 'Codex Automation'

# Controle de concorr√™ncia por branch para evitar corridas.
concurrency:
  group: ${{ github.workflow }}-${{ github.base_ref || 'scheduled-run' }}
  cancel-in-progress: true

on:
  # O FAXINEIRO: Roda a cada 15 minutos para garantir que a fila seja processada em ordem.
  schedule:
    - cron: '*/15 * * * *'
  
  # O OTIMISTA: Tenta o merge instantaneamente em qualquer atividade do PR.
  pull_request_target:
    types: [opened, labeled, reopened, synchronize]
    branches: [ 'stable', 'alpha' ]

jobs:
  process_merge_queue:
    name: 'Process Merge Queue'
    
    # Condi√ß√£o: Roda sempre no agendamento, ou se for um PR com a label 'codex'.
    if: |
      github.event_name == 'schedule' ||
      (github.event_name == 'pull_request_target' && contains(github.event.pull_request.labels.*.name, 'codex'))
      
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.CODEX_WORKFLOW_TOKEN }}
          fetch-depth: 0

      - name: 'Configure Git User'
        run: |
          git config user.name "Codex Merge Bot"
          git config user.email "actions-bot@github.com"

      - name: 'List, Sort, and Process All Codex PRs'
        env:
          GH_TOKEN: ${{ secrets.CODEX_WORKFLOW_TOKEN }}
        run: |
          set -euxo pipefail
          echo "Starting queue processing triggered by: ${{ github.event_name }}"

          # A l√≥gica agora √© sempre processar a fila inteira, garantindo a ordem.
          TARGET_BRANCHES="stable alpha"

          for BASE_BRANCH in $TARGET_BRANCHES; do
            echo ""
            echo "================================================================="
            echo ">>> Processing queue for branch: $BASE_BRANCH"
            echo "================================================================="

            # Garante que estamos na vers√£o mais recente da branch alvo antes de come√ßar a processar a fila.
            git checkout "$BASE_BRANCH"
            git reset --hard "origin/$BASE_BRANCH"

            # Lista TODOS os PRs abertos para a branch, ordena do mais antigo para o mais novo, e processa em loop.
            gh pr list --label "codex" --state "open" --base "$BASE_BRANCH" --json number,headRefName,createdAt \
            | jq -c '. | sort_by(.createdAt) | .[]' | while read -r pr_json; do
                PR_NUMBER=$(echo "$pr_json" | jq -r '.number')
                PR_BRANCH=$(echo "$pr_json" | jq -r '.headRefName')

                echo "--- Processing PR #${PR_NUMBER} into ${BASE_BRANCH} ---"

                # Trazemos a branch base para o estado mais recente ANTES de cada merge, para evitar conflitos em cascata.
                git checkout "$BASE_BRANCH"
                git reset --hard "origin/$BASE_BRANCH"
                
                # Busca a refer√™ncia do PR e tenta o merge
                git fetch origin "refs/pull/${PR_NUMBER}/head":pr_branch_to_merge
                if git merge pr_branch_to_merge --no-ff -m "Merge pull request #${PR_NUMBER}" -X theirs; then
                    echo "‚úÖ Merge successful for PR #${PR_NUMBER}."
                    git push origin "$BASE_BRANCH"
                else
                    echo "‚ùå Merge failed for PR #${PR_NUMBER}. A comment will be posted."
                    gh pr comment $PR_NUMBER --body "üö® **Merge Autom√°tico Falhou** üö® Um conflito foi detectado em '${BASE_BRANCH}' que a estrat√©gia autom√°tica n√£o conseguiu resolver. Este PR ser√° tentado novamente no pr√≥ximo ciclo."
                    # 'continue' √© crucial: se um PR falhar, ele n√£o para o loop, apenas pula para o pr√≥ximo.
                    continue
                fi
            done
          done

          echo "Queue processing finished."