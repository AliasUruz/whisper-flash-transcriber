# Whisper Flash Transcriber - Relatório de Bugs Prioritários (03/10/2025)

## Visão Geral
Auditoria focada em estabilidade, fluxo de agente e ajustes de backend revelou pontos críticos que podem impedir o uso normal do aplicativo ou gerar efeitos colaterais difíceis de diagnosticar. Os itens abaixo estão ordenados do mais difícil ao mais fácil de corrigir.

## Bugs (difícil → fácil)

### 1. Uso de `keyboard.unhook_all()` remove ganchos globais de outros aplicativos
- **Arquivo**: `src/keyboard_hotkey_manager.py:180`
- **Impacto**: Ao registrar as hotkeys o código limpa *todos* os hooks do sistema (`keyboard.unhook_all()`), inclusive aqueles adicionados por outras aplicações (p. ex. softwares de acessibilidade). Isso causa regressões externas e torna o Whisper responsável por “desregistrar” atalhos de terceiros.
- **Reprodução**: Inicie outro programa que registre atalhos globais via `keyboard` ou AutoHotkey, depois abra o Whisper Flash Transcriber; os atalhos do outro programa deixam de funcionar imediatamente.
- **Correção sugerida**:
  1. Armazenar os handles retornados por `keyboard.on_press_key`/`on_release_key` em `self.hotkey_handlers`.
  2. No cleanup, remover apenas esses handles com `keyboard.unhook(handle)` em vez de `unhook_all()`.
  3. Documentar fallback para casos em que o handle não exista mais.
- **Checklist**:
  - [ ] Salvar cada handle na estrutura `self.hotkey_handlers`.
  - [ ] Atualizar `_unregister_hotkeys` para iterar apenas pelos handles registrados.
  - [ ] Validar manualmente com outro aplicativo que registre hotkeys.

### 2. Flag de modo agente é descartada mesmo quando a gravação falha
- **Arquivo**: `src/action_orchestrator.py:56`
- **Impacto**: `_agent_mode_active` é zerado logo após a captura de áudio. Se o `TranscriptionHandler` estiver indisponível (erro de modelo, backend não carregado), o comando de agente é simplesmente perdido e a próxima tentativa volta ao fluxo padrão sem aviso ao usuário.
- **Reprodução**: Acione a hotkey de agente logo após iniciar o app (modelo ainda carregando). A tentativa falha e o modo agente não é rearmado na próxima captura.
- **Correção sugerida**:
  1. Apenas redefinir `_agent_mode_active` após confirmar que `transcribe_audio_segment` foi enfileirado com sucesso.
  2. Caso o handler esteja indisponível, manter a flag ativa e emitir notificação específica para o usuário.
- **Checklist**:
  - [ ] Ajustar `on_audio_segment_ready` para zerar a flag somente após chamada bem-sucedida.
  - [ ] Adicionar log/tooltip informando falha ao engajar o modo agente.

### 3. Fluxo legado de armazenamento (RESOLVIDO)
- **Status**: Resolvido ao consolidar o payload no campo `new_record_storage_mode` e descartar a chave histórica nos merges do `ConfigManager`.
- **Impacto original**: A UI duplicava o estado ao enviar o payload legado de armazenamento, recriando a chave obsoleta nos perfis e gerando divergência com o fluxo do `AudioHandler`.
- **Validação**: Confirmado que `config.json` permanece sincronizado apenas com `record_storage_mode` após ajustes recentes. Migrações seguem descartando o campo legado, preservando compatibilidade com perfis antigos sem reintroduzir a chave.

### 4. Registro de hotkeys falha para usuários sem privilégios elevados
- **Arquivo**: `src/keyboard_hotkey_manager.py:220`
- **Impacto**: O parâmetro `suppress=True` nos ganchos do `keyboard` exige privilégios administrativos no Windows. Em execução padrão, `keyboard` lança `ValueError` e o aplicativo fica sem atalhos.
- **Reprodução**: Execute o app como usuário padrão e tente registrar hotkeys; o log mostrará `ValueError: suppress=True requires the application to be run as administrator`.
- **Correção sugerida**:
  1. Trocar `suppress=True` por `suppress=False` (ou torná-lo configurável apenas para ambientes que suportem a supressão).
  2. Confirmar que a colagem automática continua operando.
- **Checklist**:
  - [ ] Atualizar chamadas a `keyboard.on_press_key`/`on_release_key`.
  - [ ] Testar gravação e modo agente em sessão não administrativa.
  - [ ] Ajustar documentação de requisitos.

### 5. Modo agente indisponível com backends CTranslate2/Faster-Whisper
- **Arquivo**: `src/core.py:1097`
- **Impacto**: `start_agent_command` exige `transcription_handler.pipe`, mas os backends unificados inicializam apenas `self._asr_backend`. O usuário recebe “Model not loaded” e o modo agente não inicia.
- **Reprodução**: Configure o backend para `ctranslate2`, carregue o modelo e acione a hotkey de comando agent; o log indica que o modelo não está carregado.
- **Correção sugerida**:
  1. Permitir que o modo agente use `_asr_backend` quando não houver pipeline legacy disponível.
  2. Garantir que os estados `TRANSCRIBING`/`IDLE` sejam emitidos também nesse fluxo.
- **Checklist**:
  - [ ] Ajustar `start_agent_command` e `on_audio_segment_ready` para detectar backends unificados.
  - [ ] Validar logs e UI durante o modo agente com `ctranslate2`.

### 6. Transcrição via faster-whisper falha por argumento `batch_size`
- **Arquivos**: `src/transcription_handler.py:1407`, `src/asr/backend_faster_whisper.py:43`
- **Impacto**: `_transcription_task` envia `batch_size` para `WhisperModel.transcribe`, que não aceita esse parâmetro. A exceção `TypeError` interrompe a transcrição.
- **Reprodução**: Selecione o backend `faster-whisper` e grave um trecho; o log mostra `TypeError: transcribe() got an unexpected keyword argument 'batch_size'`.
- **Correção sugerida**:
  1. Filtrar `batch_size` dos kwargs antes de chamar `WhisperModel.transcribe` ou converter para `beam_size` adequado.
  2. Adicionar teste cobrindo o backend CT2/faster-whisper.
- **Checklist**:
  - [ ] Sanitizar kwargs em `FasterWhisperBackend.transcribe`.
  - [ ] Verificar transcrição completa após o ajuste.

### 7. Backend transformers ignora o modelo solicitado (OBSOLETO)
- **Status**: Resolvido indiretamente. O backend Transformers foi removido na migração para distribuição CT2-only, portanto o problema não se aplica mais.

### 8. Backend transformers força execução na GPU 0 (OBSOLETO)
- **Status**: Resolvido indiretamente. O backend Transformers foi removido na migração para distribuição CT2-only.

### 9. Identificador incorreto de FlashAttention (OBSOLETO)
- **Status**: Resolvido indiretamente. Com a remoção do backend Transformers, o carregamento de pipelines Torch não faz mais parte do escopo oficial.

### 10. Limite de armazenamento nunca é aplicado
- **Arquivo**: `src/audio_handler.py:619`
- **Impacto**: `record_storage_limit` é lido e logado, mas nenhuma verificação impede que os arquivos em disco cresçam indefinidamente.
- **Reprodução**: Defina um limite baixo e grave múltiplas sessões; o diretório continua crescendo sem poda.
- **Correção sugerida**:
  1. Implementar controle que avalie tamanho ou quantidade de arquivos antes de iniciar nova gravação.
  2. Integrar com `_cleanup_temp_file` para excluir excedentes.
- **Checklist**:
  - [ ] Definir política clara (MB ou contagem) e aplicá-la.
  - [ ] Documentar comportamento na UI/AGENTS.md.

### 11. `asr_ct2_compute_type` não reflete a configuração
- **Arquivo**: `src/core.py:1031`
- **Impacto**: `_apply_initial_config_to_core_attributes` ainda lê `ct2_quantization`, chave inexistente, mantendo `self.ct2_quantization` como `None`. Qualquer código que consulte esse atributo opera com valor incorreto.
- **Reprodução**: Troque o compute type na UI, reinicie o app e observe que `self.ct2_quantization` permanece `None` nos logs.
- **Correção sugerida**:
  1. Ler `ASR_CT2_COMPUTE_TYPE_CONFIG_KEY` ao sincronizar o core.
  2. Remover referências à chave legada no mapa de configuração.
- **Checklist**:
  - [ ] Ajustar `_apply_initial_config_to_core_attributes`.
  - [ ] Confirmar que o valor chega ao backend CT2.

### 12. UI não aplica padding de pré/pós-fala do VAD
- **Arquivo**: `src/core.py:1156`
- **Impacto**: `config_key_map` usa as chaves antigas (`new_vad_pre_padding_ms`/`new_vad_post_padding_ms`), enquanto a UI envia `new_vad_pre_speech_padding_ms`/`new_vad_post_speech_padding_ms`. Os valores nunca são persistidos.
- **Reprodução**: Ajuste o padding na UI e salve; `config.json` mantém os valores anteriores.
- **Correção sugerida**:
  1. Alinhar as chaves no `config_key_map`.
  2. Confirmar que `ConfigManager` salva e aplica os novos valores.
- **Checklist**:
  - [ ] Ajustar o mapeamento e validar a atualização no arquivo de configuração.

### 13. Falta controle na UI para `gemini_agent_model`
- **Arquivo**: `src/ui_manager.py:2102`
- **Impacto**: A variável `agent_model_var` é criada, mas não existe widget correspondente. Usuários não conseguem trocar o modelo do modo agente apesar do suporte no núcleo.
- **Reprodução**: Tentar localizar o controle na janela de configurações; não há interação possível.
- **Correção sugerida**:
  1. Adicionar seletor (combo, radio ou campo de texto) reutilizando `gemini_model_options`.
  2. Conectar o valor ao payload `new_agent_model`.
- **Checklist**:
  - [ ] Criar o controle visual e bindar ao `agent_model_var`.
  - [ ] Atualizar documentação da UI.

### 14. Colagem automática falha no macOS
- **Arquivo**: `src/core.py:721`
- **Impacto**: `_do_paste` dispara `pyautogui.hotkey('ctrl', 'v')`. Em macOS o modificador correto é `command`, então o auto-paste nunca ocorre.
- **Reprodução**: Executar o app no macOS e gravar qualquer áudio com auto-paste ativo; o texto é copiado, mas não colado.
- **Correção sugerida**:
  1. Detectar `sys.platform` e usar `command` (`'command', 'v'`) nos sistemas Darwin.
  2. Considerar permitir override via configuração.
- **Checklist**:
  - [ ] Ajustar `_do_paste` para ser sensível ao SO.
  - [ ] Testar manualmente em macOS e Windows.

### 15. Ações da bandeja quebram por assinatura incompatível
- **Arquivo**: `src/ui_manager.py:2899`
- **Impacto**: `pystray.MenuItem` invoca callbacks com `(icon, item)`, mas os lambdas definidos não aceitam parâmetros, gerando `TypeError` ao clicar em “Iniciar/Parar gravação”, “Correção de Texto”, “Configurações” etc.
- **Reprodução**: Clique em qualquer item da bandeja; o log exibe `TypeError` e a ação não é executada.
- **Correção sugerida**:
  1. Ajustar callbacks para receber `*args` ou usar `functools.partial`.
  2. Garantir que todas as ações compartilhem a mesma assinatura.
- **Checklist**:
  - [ ] Atualizar todos os `MenuItem`.
  - [ ] Testar manualmente cada entrada da bandeja.

### 16. Filtro ANSI não remove sequências de escape
- **Arquivo**: `src/logging_utils.py:24`
- **Impacto**: `ANSI_ESCAPE_RE` perdeu o prefixo `\x1B`, logo nenhuma sequência ANSI é filtrada e códigos de cor aparecem nos logs e arquivos.
- **Reprodução**: Execute o app com logs coloridos; observe sequências `\[0;31m` nos arquivos de log.
- **Correção sugerida**:
  1. Restabelecer o padrão completo (ex.: `\x1B\[[0-9;]*[A-Za-z]`).
  2. Adicionar teste unitário simples validando a limpeza.
- **Checklist**:
  - [ ] Corrigir a regex.
  - [ ] Criar teste rápido em `tests/` cobrindo o filtro.
